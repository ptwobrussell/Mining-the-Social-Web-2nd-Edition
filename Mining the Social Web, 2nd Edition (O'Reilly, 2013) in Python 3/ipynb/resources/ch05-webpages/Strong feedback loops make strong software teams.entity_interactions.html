<html>
    <head>
        <title>Strong feedback loops make strong software teams Interactions</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    </head>
    <body><strong>Enhance</strong> overall <strong>code quality</strong> through a <strong>blend</strong> of interpersonal <strong>communication</strong> and tool-based <strong>analysis.Software quality</strong> takes time. And good <strong>quality</strong> <strong>products</strong> come from properly working <strong>feedback</strong> loops. Timely <strong>feedback</strong> can mean <strong>clarity</strong> over <strong>confusion</strong>; a <strong>validation</strong> of <strong>assumptions</strong> can mean shorter <strong>development</strong> cycles. For <strong>example</strong>, let<strong>’</strong>s say you have a <strong>project</strong> that needs to be delivered next <strong>month</strong>, but you and your <strong>development team</strong> know it will take at least two more <strong>month</strong>s to complete. How do you communicate this to key stakeholders? <strong>First</strong> off, you need to establish a shared <strong>understanding</strong> of <strong>goals</strong> and <strong>quality</strong> amongst all involved participants. As a <strong>developer</strong>, you tend to base your <strong>behavior</strong> and <strong>build</strong> <strong>products</strong> and <strong>architectures</strong> around <strong>values</strong> and assumptions. If these <strong>values</strong> and <strong>assumptions</strong> are not aligned and validated, you will never end up with what you intended—let alone on <strong>time</strong> and within budget. Assuming your <strong>assumptions</strong> are accurate, you get carried a<strong>way</strong> and spend <strong>way</strong> too much <strong>time</strong> on <strong>something</strong> before gathering feedback. But honestly, when would you rather hear all of your <strong>effort</strong> was a <strong>waste</strong>: after you spent a <strong>day</strong> working on it, or after working on it for a week? A <strong>feedback loop</strong> is straightforward: it uses its <strong>input</strong> as one of its <strong>input</strong>s. In its simplest <strong>form</strong>, a <strong>developer</strong> changes a <strong>code base</strong> and then gets feedback from the <strong>system</strong> by unit testing. This <strong>feedback</strong> will now be <strong>input</strong> for the <strong>developer</strong><strong>’</strong>s next <strong>steps</strong> to improve the code. However, reality is not that simple. Plus, <strong>humans</strong> have an irrepressible <strong>tendency</strong> to include as many <strong>people</strong> as possible in one loop. If you follow such a <strong>course</strong>, you’ll <strong>end</strong> up with feedback <strong>chaos</strong>: massive <strong>“</strong><strong>loops</strong>” including every potential <strong>player</strong> make it impossible to control, validate <strong>assumptions</strong>, and create a shared <strong>sense</strong> of reality. Quite simply, there’s too much going on. But there<strong>’</strong>s a <strong>solution</strong>: reflection. <strong>Reflection</strong> helps you identify existing <strong>feedback</strong> <strong>loops</strong> and determine who needs to be included. The shorter the feedback loop, the better. There are two <strong>forms</strong> of <strong>feedback</strong>: personal and tool based. Personal <strong>feedback</strong> is given on an interpersonal <strong>level—people</strong> discussing <strong>code</strong>, <strong>products</strong>, or <strong>processes</strong> and identifying where things can be improved. Tool-based <strong><strong>feedback</strong></strong>, such as static <strong>analysis</strong>, provides you with <strong><strong>code</strong></strong>-level <strong><strong>feedback</strong></strong> and <strong>tells</strong> you where to improve your <strong><strong>code</strong></strong> (or specific <strong>parts</strong> of your <strong><strong>code</strong></strong>) to increase quality. Personal <strong>feedback</strong> is often specific for <strong>projects</strong>, more sensitive to context, and offers concrete suggestions to implement. Tool-based <strong>feedback</strong> <strong>enables</strong> faster <strong>feedback</strong> loops, allows for <strong>scalability</strong> by iteration, and is more objective. But which form of feedback is better? There is a false <strong>dichotomy</strong> between full <strong>automation</strong> and human intervention. Successful <strong>quality control</strong> combines tool-based <strong>measurement</strong> with manual <strong>review</strong> and discussion. At the <strong>end</strong> of the <strong>day</strong>, the most effective <strong>feedback</strong> <strong>loops</strong> are a <strong>mixture</strong> of daily best <strong>practices</strong>, <strong>automation</strong>, <strong>tools</strong>, and human intervention. In an upcoming follow-up <strong>post</strong>, I’ll <strong>discuss</strong> specific <strong>practices</strong> that integrate personal and tool-based feedback. These <strong>practices</strong> will help you bolster your <strong>code</strong> and architectural quality. This <strong>post</strong> is a <strong>collaboration</strong> between <strong>O'Reilly</strong> and SIG. See our statement of editorial independence. <strong>Continue</strong> reading <strong>Strong</strong> <strong>feedback</strong> <strong>loops</strong> make strong <strong>software</strong> teams.</body>
</html>